// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.
#ifndef NETEASE_FRAGMENT_COMMON_H
#define NETEASE_FRAGMENT_COMMON_H

// To use centroid sampling we need to have version 300 es shaders, which requires changing:
// attribute to in
// varying to out when in vertex shaders or in when in fragment shaders
// defining an out vec4 FragColor and replacing uses of gl_FragColor with FragColor
// texture2D to texture
#if __VERSION__ >= 300

#ifdef MSAA_FRAMEBUFFER_ENABLED
#define _centroid centroid
#else
#define _centroid
#endif

// version 300 code
_centroid in vec2 uv;

#define varying in
#define texture2D texture
out vec4 FragColor;
#define gl_FragColor FragColor

#else

// version 100 code
varying vec2 uv;

#endif

#ifndef _UNIFORM_ENTITY_CONSTANTS_H
#define _UNIFORM_ENTITY_CONSTANTS_H

#ifndef _UNIFORM_MACRO_H
#define _UNIFORM_MACRO_H

#ifdef MCPE_PLATFORM_NX
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) uniform x {
#define END_UNIFORM_BLOCK };
#define UNIFORM 
#else
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) 
#define END_UNIFORM_BLOCK
#define UNIFORM uniform 
#endif

#if __VERSION__ >= 420
#define LAYOUT_BINDING(x) layout(binding = x)
#else
#define LAYOUT_BINDING(x) 
#endif

#endif


#ifdef MCPE_PLATFORM_NX
uniform ActorConstants {
#endif
// BEGIN_UNIFORM_BLOCK(ActorConstants) - unfortunately this macro does not work on old Amazon platforms so using above 3 lines instead
UNIFORM vec4 OVERLAY_COLOR;
UNIFORM vec4 TILE_LIGHT_COLOR;
UNIFORM vec4 CHANGE_COLOR;
UNIFORM vec4 GLINT_COLOR;
UNIFORM vec4 UV_ANIM;
UNIFORM vec2 UV_OFFSET;
UNIFORM vec2 UV_ROTATION;
UNIFORM vec2 GLINT_UV_SCALE;
UNIFORM vec4 MULTIPLICATIVE_TINT_CHANGE_COLOR;
END_UNIFORM_BLOCK

#endif

#ifndef _UNIFORM_SHADER_CONSTANTS_H
#define _UNIFORM_SHADER_CONSTANTS_H

#ifndef _UNIFORM_MACRO_H
#define _UNIFORM_MACRO_H

#ifdef MCPE_PLATFORM_NX
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) uniform x {
#define END_UNIFORM_BLOCK };
#define UNIFORM 
#else
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) 
#define END_UNIFORM_BLOCK
#define UNIFORM uniform 
#endif

#if __VERSION__ >= 420
#define LAYOUT_BINDING(x) layout(binding = x)
#else
#define LAYOUT_BINDING(x) 
#endif

#endif


#ifdef MCPE_PLATFORM_NX
#extension GL_ARB_enhanced_layouts : enable
layout(binding = 3) uniform ShaderConstants {
#endif
// BEGIN_UNIFORM_BLOCK(ShaderConstants) - unfortunately this macro does not work on old Amazon platforms so using above 3 lines instead
UNIFORM vec4 CURRENT_COLOR;
UNIFORM vec4 DARKEN;
UNIFORM vec3 TEXTURE_DIMENSIONS;
UNIFORM float HUD_OPACITY;
UNIFORM MAT4 UV_TRANSFORM;
END_UNIFORM_BLOCK

#endif

#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
#define USE_TEXEL_AA 0
#else
#define USE_TEXEL_AA 1
#endif

#ifdef ALPHA_TEST
#define USE_ALPHA_TEST 1
#else
#define USE_ALPHA_TEST 0
#endif

#if __VERSION__ >= 300

#ifndef _UNIFORM_SHADER_CONSTANTS_H
#define _UNIFORM_SHADER_CONSTANTS_H

#ifndef _UNIFORM_MACRO_H
#define _UNIFORM_MACRO_H

#ifdef MCPE_PLATFORM_NX
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) uniform x {
#define END_UNIFORM_BLOCK };
#define UNIFORM 
#else
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) 
#define END_UNIFORM_BLOCK
#define UNIFORM uniform 
#endif

#if __VERSION__ >= 420
#define LAYOUT_BINDING(x) layout(binding = x)
#else
#define LAYOUT_BINDING(x) 
#endif

#endif


#ifdef MCPE_PLATFORM_NX
#extension GL_ARB_enhanced_layouts : enable
layout(binding = 3) uniform ShaderConstants {
#endif
// BEGIN_UNIFORM_BLOCK(ShaderConstants) - unfortunately this macro does not work on old Amazon platforms so using above 3 lines instead
UNIFORM vec4 CURRENT_COLOR;
UNIFORM vec4 DARKEN;
UNIFORM vec3 TEXTURE_DIMENSIONS;
UNIFORM float HUD_OPACITY;
UNIFORM MAT4 UV_TRANSFORM;
END_UNIFORM_BLOCK

#endif


#if USE_TEXEL_AA

const float TEXEL_AA_LOD_CONSERVATIVE = -1.0;
const float TEXEL_AA_LOD_RELAXED = 2.0;

vec4 texture2D_AA(in sampler2D source, in highp vec2 originalUV) {

	highp vec2 dUV_dX = dFdx(originalUV) * TEXTURE_DIMENSIONS.xy;
	highp vec2 dUV_dY = dFdy(originalUV) * TEXTURE_DIMENSIONS.xy;

	highp vec2 delU = vec2(dUV_dX.x, dUV_dY.x);
	highp vec2 delV = vec2(dUV_dX.y, dUV_dY.y);
	highp vec2 adjustmentScalar = max(1.0 / vec2(length(delU), length(delV)), 1.0);

	highp vec2 fractionalTexel = fract(originalUV * TEXTURE_DIMENSIONS.xy);
	highp vec2 adjustedFractionalTexel = clamp(fractionalTexel * adjustmentScalar, 0.0, 0.5) + clamp(fractionalTexel * adjustmentScalar - (adjustmentScalar - 0.5), 0.0, 0.5);

	highp float lod = log2(sqrt(max(dot(dUV_dX, dUV_dX), dot(dUV_dY, dUV_dY))) * 2.0);
	highp float samplingMode = smoothstep(TEXEL_AA_LOD_RELAXED, TEXEL_AA_LOD_CONSERVATIVE, lod);

	highp vec2 adjustedUV = (adjustedFractionalTexel + floor(originalUV * TEXTURE_DIMENSIONS.xy)) / TEXTURE_DIMENSIONS.xy;
	lowp vec4 blendedSample = texture2D(source, mix(originalUV, adjustedUV, samplingMode));

	#if USE_ALPHA_TEST
		return vec4(blendedSample.rgb, mix(blendedSample.a, smoothstep(1.0/2.0, 1.0, blendedSample.a), samplingMode));
	#else
		return blendedSample;
	#endif
}

#endif // USE_TEXEL_AA

#endif //__VERSION__ >= 300


#line 9

#ifdef USE_EMISSIVE
	#ifdef USE_ONLY_EMISSIVE
		#define NEEDS_DISCARD(C) (C.a == 0.0 || C.a == 1.0 )
	#else
		#define NEEDS_DISCARD(C) (C.a + C.r + C.g + C.b == 0.0)
	#endif
#else
	#ifndef USE_COLOR_MASK
		#define NEEDS_DISCARD(C) (C.a < 0.5)
	#else
		#define NEEDS_DISCARD(C) (C.a == 0.0)
	#endif
#endif

/**************** Preset Variables Begin ****************/
#if defined(USE_ALPHA) || defined(USE_BRIGHT)
uniform vec4 HIDE_COLOR;
#endif

#ifdef PET_DISTANCE_ALPHA
	varying float cameraDistance;
#endif

#ifdef VIP_MOUNT_ALPHA
	varying float cameraDistToMount;
#endif

#ifdef GLINT
	varying vec2 layer1UV;
	varying vec2 layer2UV;
	varying vec4 glintColor;
	varying vec4 tileLightColor;
#endif

#ifdef USE_OVERLAY
	// When drawing horses on specific android devices, overlay color ends up being garbage data.
	// Changing overlay color to high precision appears to fix the issue on devices tested
	varying highp vec4 overlayColor;
#endif
/**************** Preset Variables End ****************/


vec4 glintBlend(vec4 dest, vec4 source) {
	// glBlendFuncSeparate(GL_SRC_COLOR, GL_ONE, GL_ONE, GL_ZERO)
	return vec4(source.rgb * source.rgb, abs(source.a)) + vec4(dest.rgb, 0.0);
}

vec4 getSampledColor(sampler2D texToSample, vec2 uv) {
	vec4 color;
#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
	color = texture2D( texToSample, uv );
#else
	color = texture2D_AA(texToSample, uv);
#endif
	return color;
}

void applyOverlayColor(inout vec4 color) {
#ifdef USE_OVERLAY
	//use either the diffuse or the OVERLAY_COLOR
	color.rgb = mix(color, overlayColor, overlayColor.a).rgb;
#endif
}

void applyGlint(sampler2D glintTexture, inout vec4 color) {
#ifdef GLINT
	// Applies color mask to glint texture instead and blends with original color
	vec4 layer1 = texture2D(glintTexture, fract(layer1UV)).rgbr * glintColor;
	vec4 layer2 = texture2D(glintTexture, fract(layer2UV)).rgbr * glintColor;
	vec4 glint = (layer1 + layer2) * tileLightColor;

	color = glintBlend(color, glint);
#endif
}

float getBloomMask(sampler2D bloomTexture, vec2 uv) {
	float bloomMask = 1.0;
// sample bloom mask value
#if !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
	bloomMask = texture2D(bloomTexture, uv).r;
#else
	bloomMask = texture2D_AA(bloomTexture, uv).r;
#endif // !defined(TEXEL_AA) || !defined(TEXEL_AA_FEATURE)
	return bloomMask;
}

float getEmissive(sampler2D emissiveTex, vec2 uv) {
#ifdef USE_BLOOM
	return getBloomMask(emissiveTex, uv);
#else
	return 0.0;
#endif
}

void applyFog(inout vec4 color, vec4 fogColor) {
	color.rgb = mix( color.rgb, fogColor.rgb, fogColor.a );
}

void neteaseModelCommonFrag(inout vec4 color) {
#ifdef USE_ALPHA
	color.a *= HIDE_COLOR.a;
#endif

#ifdef PET_SKILL_TIPS_PREVIEW
	color.rgb = mix(color.rgb, vec3(0, 0, 1), 0.6);
	color.a = 0.4;
#endif

#ifdef USE_BRIGHT
	color.rgb *= HIDE_COLOR.a;
#endif

// PET_DISTANCE_ALPHA and VIP_MOUNT_ALPHA shouldn't work simultaneously
#ifdef PET_DISTANCE_ALPHA
	color.a = 0.5 + step(2.0, cameraDistance) * 0.5;
#endif

#ifdef VIP_MOUNT_ALPHA
	color.a = 0.25 + step(2.5, cameraDistToMount) * 0.75;
#endif

#if defined(ALPHA_TEST)
	if(NEEDS_DISCARD(color))
		discard;
#endif
}

#endif // NETEASE_FRAGMENT_COMMON_H

#line 4

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
#if defined(GLINT) && defined(USE_BLOOM)
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;
#endif
// LAYOUT_BINDING(3) uniform sampler2D TEXTURE_3; // 最多允许四张贴图

varying vec4 light;
varying vec4 fogColor;

void main() {
	// 根据uv获取纹理色 如果是用了NO_TEXTURE宏则会返回 1.0
	vec4 color = getSampledColor(TEXTURE_0, uv);

	// 杂项的内置宏功能
	neteaseModelCommonFrag(color);

	// 加入受击变红等效果
	applyOverlayColor(color);

	// 附魔变色效果 使用TEXTURE_1
	applyGlint(TEXTURE_1, color);

	// 光照计算
#if defined(GLINT) && defined(USE_BLOOM)
	// 带有附魔效果的材质占用了TEXTURE_1 因此这里使用TEXTURE_2作为发光遮罩贴图
	lowp float emissive = getEmissive(TEXTURE_2, uv);
#else
	lowp float emissive = getEmissive(TEXTURE_1, uv);
#endif
	// bloomMask超过阈值时 本体发光 否则应用默认光照
	color.rgb *= (emissive < 0.1) ? light.rgb : vec3(emissive);

	// 雾效果
	applyFog(color, fogColor);

	gl_FragColor = color;
}
